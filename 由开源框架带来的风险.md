# 由开源框架带来的风险
## 识别可能出现的风险
### 开源项目子目录或文件形式包含
>某些项目依赖于特定开源组件功能，但出于维持明确的依赖关系、清晰的制品形式的目的，并不会动态链接（依赖）独立的软件包或动态库，而是将固定版本的开源代码，完整目录或者裁剪的部分文件形式，直接包含在代码目录下，同步编译静态链接在制品二进制中。

>这种情况下，开发者的诉求一般是追求“稳定可用即可”，并规避依赖子模块接口更新带来的维护成本，更不会主动关注子模块是否有安全更新并跟进，因此很容易存在有历史漏洞的成分。

>例如，Java 开发的移动端通信 SDK 和软件 Telegram，以 jni 调用形式包含了 boringssl，而后者是 Google 自 OpenSSL 1.1.0 历史分支 fork 并维护的二次开发项目。虽然 boringssl 以一定机制跟进了上游的漏洞修复，但 Telegram 对这些依赖的更新没有确定策略，最后一次更新 boringssl 停留在 2020.8.15，因此近两年多的漏洞都可能影响着 Telegram（如果构造出合理的调用路径），并进一步影响封装 Telegram 的更下游应用，如 Nekogram。

### 函数和片段级别代码复用（复制）
> 开源代码往往也成为开发实践中取之不竭的代码模板和材料。对于某些典型原子功能的实现，开发者“借用”开源代码片段并依据自己项目的上下文做适当修改变形，是较为普遍，但又无法评估存在占比的实践。根据 Synopsys 今年在 17 个商业体超过 2400 个商用软件代码仓库中分析后，形成的开源安全与风险分析报告认为，商业软件中 78%比例的代码实际是开源代码。

>在我们对开源代码的分析中，也有一定量的代码复用，并随着复用的旧版本开源代码引入潜在脆弱代码的案例。例如，某款韩国 自研 的 IoT 专用安全库中的密码算法实现中，即发现了疑似复制自 OpenSSL 密码算法库中中国 SM2 算法的功能实现，且复制版本为被爆出高危漏洞CVE-2021-3711的修补前函数。

### 数据结构和接口调用的语法复用
> 另一种典型的问题是数据结构和接口的误用。对某些未充分文档化的数据结构和功能接口，项目内部协作的开发者可能存在共通的错误理解和误用情况；作为 SDK 导出的接口被下游开发者误用的情况更是屡见不鲜。此时就会看到针对一个漏洞根因的多处位置、语法各异但语用同源的漏洞，这样的案例屡见不鲜。

> 一个很容易理解的案例是，OpenSSL 漏洞 CVE-2021-3712，根因在于定义的结构体 ASN1_IA5STRING，其中带有一个非'\0'结尾的缓冲区指针，和缓冲区有效数据长度字段；但大量开源协作开发者未意识到缓冲区并非标准 C 样式字符串，而使用了不安全的字符串操作函数，例如 sprintf, strdup, strcat, strchr 等以及其在 OpenSSL 中的封装版本，从而造成了多处缓冲区越界访问或写溢出等。进一步地，这个数据结构也被导出，从而被一些依赖的下游项目同样误用，造成漏洞的修复无法收敛。